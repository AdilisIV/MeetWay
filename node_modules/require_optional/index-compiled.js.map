{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["var path = require('path'),\n  fs = require('fs'),\n  f = require('util').format,\n  resolveFrom = require('resolve-from'),\n  semver = require('semver');\n\nvar exists = fs.existsSync || path.existsSync;\n\n// Find the location of a package.json file near or above the given location\nvar find_package_json = function(location) {\n  var found = false;\n\n  while(!found) {\n    if (exists(location + '/package.json')) {\n      found = location;\n    } else if (location !== '/') {\n      location = path.dirname(location);\n    } else {\n      return false;\n    }\n  }\n\n  return location;\n}\n\n// Find the package.json object of the module closest up the module call tree that contains name in that module's peerOptionalDependencies\nvar find_package_json_with_name = function(name) {\n  // Walk up the module call tree until we find a module containing name in its peerOptionalDependencies\n  var currentModule = module;\n  var found = false;\n  while (currentModule) {\n    // Check currentModule has a package.json\n    location = currentModule.filename;\n    var location = find_package_json(location)\n    if (!location) {\n      currentModule = currentModule.parent;\n      continue;\n    }\n\n    // Read the package.json file\n    var object = JSON.parse(fs.readFileSync(f('%s/package.json', location)));\n    // Is the name defined by interal file references\n    var parts = name.split(/\\//);\n\n    // Check whether this package.json contains peerOptionalDependencies containing the name we're searching for\n    if (!object.peerOptionalDependencies || (object.peerOptionalDependencies && !object.peerOptionalDependencies[parts[0]])) {\n      currentModule = currentModule.parent;\n      continue;\n    }\n    found = true;\n    break;\n  }\n\n  // Check whether name has been found in currentModule's peerOptionalDependencies\n  if (!found) {\n    throw new Error(f('no optional dependency [%s] defined in peerOptionalDependencies in any package.json', parts[0]));\n  }\n\n  return {\n    object: object,\n    parts: parts\n  }\n}\n\nvar require_optional = function(name, options) {\n  options = options || {};\n  options.strict = typeof options.strict == 'boolean' ? options.strict : true;\n\n  var res = find_package_json_with_name(name)\n  var object = res.object;\n  var parts = res.parts;\n\n  // Unpack the expected version\n  var expectedVersions = object.peerOptionalDependencies[parts[0]];\n  // The resolved package\n  var moduleEntry = undefined;\n  // Module file\n  var moduleEntryFile = name;\n\n  try {\n    // Validate if it's possible to read the module\n    moduleEntry = require(moduleEntryFile);\n  } catch(err) {\n    // Attempt to resolve in top level package\n    try {\n      // Get the module entry file\n      moduleEntryFile = resolveFrom(process.cwd(), name);\n      if(moduleEntryFile == null) return undefined;\n      // Attempt to resolve the module\n      moduleEntry = require(moduleEntryFile);\n    } catch(err) {\n      if(err.code === 'MODULE_NOT_FOUND') return undefined;\n    }\n  }\n\n  // Resolve the location of the module's package.json file\n  var location = find_package_json(require.resolve(moduleEntryFile));\n  if(!location) {\n    throw new Error('package.json can not be located');\n  }\n\n  // Read the module file\n  var dependentOnModule = JSON.parse(fs.readFileSync(f('%s/package.json', location)));\n  // Get the version\n  var version = dependentOnModule.version;\n  // Validate if the found module satisfies the version id\n  if(semver.satisfies(version, expectedVersions) == false\n    && options.strict) {\n      var error = new Error(f('optional dependency [%s] found but version [%s] did not satisfy constraint [%s]', parts[0], version, expectedVersions));\n      error.code = 'OPTIONAL_MODULE_NOT_FOUND';\n      throw error;\n  }\n\n  // Satifies the module requirement\n  return moduleEntry;\n}\n\nrequire_optional.exists = function(name) {\n  try {\n    var m = require_optional(name);\n    if(m === undefined) return false;\n    return true;\n  } catch(err) {\n    return false;\n  }\n}\n\nmodule.exports = require_optional;\n"]}