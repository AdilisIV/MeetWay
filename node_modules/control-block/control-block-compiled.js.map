{"version":3,"sources":["control-block.js"],"names":[],"mappings":"AAAA;;;AAGA,SAAS,KAAT,CAAe,OAAf,EAAwB;AACvB,MAAK,OAAL,GAAa,MAAM,OAAnB;AACA,MAAK,QAAL,GAAc,OAAd;AACA;AACD,MAAM,OAAN,GAAc,IAAd;;AAEA;;;;;;;;AAQA,MAAM,KAAN,GAAY,UAAS,CAAT,EAAY;AACvB,KAAI,KAAK,OAAT,EAAkB,OAAO,KAAK,OAAL,CAAa,KAAb,CAAmB,CAAnB,CAAP,CAAlB,KACK,OAAO,CAAP;AACL,CAHD;;AAKA;;;;;;;;AAQA,MAAM,KAAN,GAAY,UAAS,KAAT,EAAgB,MAAhB,EAAwB;AACnC,KAAI,KAAG,IAAI,KAAJ,CAAU,MAAV,CAAP;AACA,QAAO,GAAG,IAAH,CAAQ,KAAR,CAAP;AACA,CAHD;;AAKA;;;;;;;;AAQA,MAAM,YAAN,GAAmB,YAAW;AAC7B;AACA,KAAI,UAAQ,KAAK,OAAjB;;AAEA,QAAO,UAAS,GAAT,EAAc;AACpB,MAAI,CAAC,GAAL,EAAU;AACV,MAAI,OAAJ,EAAa,OAAO,QAAQ,KAAR,CAAc,GAAd,CAAP,CAAb,KACK,MAAM,GAAN;AACL,EAJD;AAKA,CATD;;AAWA;;;;;;;;AAQA,MAAM,SAAN,CAAgB,KAAhB,GAAsB,UAAS,GAAT,EAAc;AACnC,KAAI,KAAK,QAAT,EAAmB;AAClB,MAAI;AACH,QAAK,QAAL,CAAc,GAAd;AACA,GAFD,CAEE,OAAO,OAAP,EAAgB;AACjB,OAAI,KAAK,OAAT,EAAkB,KAAK,OAAL,CAAa,KAAb,CAAmB,OAAnB,EAAlB,KACK,MAAM,OAAN;AACL;AACD,EAPD,MAOO;AACN,MAAI,KAAK,OAAT,EAAkB,KAAK,OAAL,CAAa,KAAb,CAAmB,GAAnB,EAAlB,KACK,MAAM,GAAN;AACL;AACD,CAZD;;AAcA;;;;;AAKA,MAAM,SAAN,CAAgB,IAAhB,GAAqB,UAAS,QAAT,EAAmB;AACvC,KAAI,cAAY,MAAM,OAAtB;AACA,OAAM,OAAN,GAAc,IAAd;AACA,KAAI;AACH,MAAI,MAAI,UAAR;AACA,QAAM,OAAN,GAAc,WAAd;AACA,SAAO,GAAP;AACA,EAJD,CAIE,OAAO,CAAP,EAAU;AACX,QAAM,OAAN,GAAc,WAAd;AACA,OAAK,KAAL,CAAW,CAAX;AACA;AACD,CAXD;;AAaA;;;;;;AAMA,MAAM,SAAN,CAAgB,KAAhB,GAAsB,UAAS,CAAT,EAAY;AACjC,KAAI,EAAE,WAAN,EAAmB,OAAO,CAAP;AACnB,KAAI,OAAK,IAAT;AACA,KAAI,UAAQ,YAAW;AACtB,MAAI,cAAY,MAAM,OAAtB;AACA,QAAM,OAAN,GAAc,IAAd;AACA,MAAI;AACH,OAAI,MAAI,EAAE,KAAF,CAAQ,IAAR,EAAc,SAAd,CAAR;AACA,SAAM,OAAN,GAAc,WAAd;AACA,UAAO,GAAP;AACA,GAJD,CAIE,OAAO,CAAP,EAAU;AACX,SAAM,OAAN,GAAc,WAAd;AACA,QAAK,KAAL,CAAW,CAAX;AACA;AACD,EAXD;AAYA,SAAQ,WAAR,GAAoB,IAApB;AACA,QAAO,OAAP;AACA,CAjBD;;AAmBA;AACA,QAAQ,KAAR,GAAc,KAAd","file":"control-block-compiled.js","sourcesContent":["/**\n * Block class is used for routing errors to higher level logic.\n */\nfunction Block(errback) {\n\tthis._parent=Block.current;\n\tthis._errback=errback;\n}\nBlock.current=null;\n\n/**\n * Wrap a function such that any exceptions it generates\n * are sent to the error callback of the Block that is active\n * at the time of the call to guard().  If no Block\n * is active, just returns the function.\n *\n * Example: stream.on('end', Block.guard(function() { ... }));\n */\nBlock.guard=function(f) {\n\tif (this.current) return this.current.guard(f);\n\telse return f;\n};\n\n/**\n * Begins a new Block with two callback functions.  The first\n * is the main part of the block (think 'try body'), the\n * second is the rescue function/error callback (think 'catch').\n * The terminology follows Ruby for no other reason than that\n * Block, begin and rescue describe an exception handling\n * paradigm and are not reserved words in JavaScript.\n */\nBlock.begin=function(block, rescue) {\n\tvar ec=new Block(rescue);\n\treturn ec.trap(block);\n};\n\n/**\n * Returns a function(err) that can be invoked at any time to raise\n * an exception against the now current block (or the current context\n * if no current).  Errors are only raised if the err argument is true\n * so this can be used in both error callbacks and error events.\n *\n * Example: request.on('error', Block.errorHandler())\n */\nBlock.errorHandler=function() {\n\t// Capture the now current Block for later\n\tvar current=this.current;\n\t\n\treturn function(err) {\n\t\tif (!err) return;\n\t\tif (current) return current.raise(err);\n\t\telse throw err;\n\t};\n};\n\n/**\n * Raises an exception on the Block.  If the block has an\n * error callback, it is given the exception.  Otherwise,\n * raise(...) is called on the parent block.  If there is\n * no parent, the exception is simply raised.\n * Any nested exceptions from error callbacks will be raised\n * on the block's parent.\n */\nBlock.prototype.raise=function(err) {\n\tif (this._errback) {\n\t\ttry {\n\t\t\tthis._errback(err);\n\t\t} catch (nestedE) {\n\t\t\tif (this._parent) this._parent.raise(nestedE);\n\t\t\telse throw nestedE;\n\t\t}\n\t} else {\n\t\tif (this._parent) this._parent.raise(err);\n\t\telse throw(err);\n\t}\n};\n\n/**\n * Executes a callback in the context of this block.  Any\n * errors will be passed to this Block's raise() method.\n * Returns the value of the callback or undefined on error.\n */\nBlock.prototype.trap=function(callback) {\n\tvar origCurrent=Block.current;\n\tBlock.current=this;\n\ttry {\n\t\tvar ret=callback();\n\t\tBlock.current=origCurrent;\n\t\treturn ret;\n\t} catch (e) {\n\t\tBlock.current=origCurrent;\n\t\tthis.raise(e);\n\t}\n};\n\n/**\n * Wraps a function and returns a function that routes\n * errors to this block.  This is similar to trap but\n * returns a new function instead of invoking the callback\n * immediately.\n */\nBlock.prototype.guard=function(f) {\n\tif (f.__guarded__) return f;\n\tvar self=this;\n\tvar wrapped=function() {\n\t\tvar origCurrent=Block.current;\n\t\tBlock.current=self;\n\t\ttry {\n\t\t\tvar ret=f.apply(this, arguments);\n\t\t\tBlock.current=origCurrent;\n\t\t\treturn ret;\n\t\t} catch (e) {\n\t\t\tBlock.current=origCurrent;\n\t\t\tself.raise(e);\n\t\t}\n\t};\n\twrapped.__guarded__=true;\n\treturn wrapped;\n};\n\n// -- exports\nexports.Block=Block;\n"]}